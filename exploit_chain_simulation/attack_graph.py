#!/usr/bin/env python3
"""
CVE-2024-53197 Attack Graph Generator

Generates visual and structural representations of the exploit chain
for the USB Audio boot quirk vulnerability.

Target: Sony NW-A306 Walkman (kernel 4.19.157)
"""

import json
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from enum import Enum


class NodeType(Enum):
    """Types of nodes in the attack graph"""
    ENTRY = "entry"           # Attack entry point
    CONDITION = "condition"   # Trigger condition
    ACTION = "action"         # Kernel/driver action
    VULNERABILITY = "vuln"    # Vulnerable code path
    PRIMITIVE = "primitive"   # Exploitation primitive gained
    GOAL = "goal"            # Attack goal/outcome


class EdgeType(Enum):
    """Types of edges connecting nodes"""
    TRIGGERS = "triggers"
    ENABLES = "enables"
    REQUIRES = "requires"
    LEADS_TO = "leads_to"
    EXPLOITS = "exploits"


@dataclass
class AttackNode:
    """Node in the attack graph"""
    id: str
    name: str
    node_type: NodeType
    description: str
    details: Dict[str, Any] = field(default_factory=dict)
    kernel_function: Optional[str] = None
    kernel_file: Optional[str] = None
    line_number: Optional[int] = None

    def to_dict(self) -> Dict:
        d = asdict(self)
        d['node_type'] = self.node_type.value
        return d


@dataclass
class AttackEdge:
    """Edge connecting attack nodes"""
    source: str
    target: str
    edge_type: EdgeType
    description: str = ""
    probability: float = 1.0  # Success probability

    def to_dict(self) -> Dict:
        d = asdict(self)
        d['edge_type'] = self.edge_type.value
        return d


@dataclass
class AttackPath:
    """A complete path through the attack graph"""
    name: str
    description: str
    nodes: List[str]
    success_probability: float
    requirements: List[str] = field(default_factory=list)
    mitigations: List[str] = field(default_factory=list)


class CVE202453197AttackGraph:
    """
    Attack graph for CVE-2024-53197 USB Audio exploitation
    """

    def __init__(self):
        self.nodes: Dict[str, AttackNode] = {}
        self.edges: List[AttackEdge] = []
        self.paths: List[AttackPath] = []

        self._build_graph()

    def _build_graph(self):
        """Construct the complete attack graph"""
        self._add_entry_points()
        self._add_trigger_conditions()
        self._add_vulnerable_paths()
        self._add_primitives()
        self._add_goals()
        self._add_edges()
        self._compute_attack_paths()

    def _add_entry_points(self):
        """Add attack entry point nodes"""
        self.nodes["usb_connect"] = AttackNode(
            id="usb_connect",
            name="USB Device Connection",
            node_type=NodeType.ENTRY,
            description="Connect malicious USB audio device to target",
            details={
                "attack_hardware": ["Raspberry Pi Zero", "Facedancer", "GreatFET"],
                "connection_type": "USB-C OTG",
                "timing": "Device must be powered on"
            }
        )

        self.nodes["device_enum"] = AttackNode(
            id="device_enum",
            name="USB Enumeration",
            node_type=NodeType.ACTION,
            description="Kernel enumerates USB device, reads descriptors",
            kernel_function="usb_new_device",
            kernel_file="drivers/usb/core/hub.c",
            details={
                "descriptor_type": "Device Descriptor",
                "critical_field": "bNumConfigurations",
                "initial_value": 1
            }
        )

    def _add_trigger_conditions(self):
        """Add condition nodes for triggering the vulnerability"""
        self.nodes["vid_pid_match"] = AttackNode(
            id="vid_pid_match",
            name="VID:PID Match",
            node_type=NodeType.CONDITION,
            description="Device VID:PID matches Extigy or FastTrackPro",
            details={
                "extigy": {"vid": "0x041e", "pid": "0x3000"},
                "fasttrackpro": {"vid": "0x0763", "pid": "0x2012"}
            }
        )

        self.nodes["fw_size_match"] = AttackNode(
            id="fw_size_match",
            name="Firmware Size Match",
            node_type=NodeType.CONDITION,
            description="wTotalLength matches boot firmware size constant",
            details={
                "EXTIGY_FIRMWARE_SIZE_OLD": 794,
                "EXTIGY_FIRMWARE_SIZE_NEW": 483
            }
        )

        self.nodes["config_alloc"] = AttackNode(
            id="config_alloc",
            name="Config Array Allocation",
            node_type=NodeType.ACTION,
            description="Kernel allocates usb_host_config array based on initial bNumConfigurations",
            kernel_function="usb_get_configuration",
            kernel_file="drivers/usb/core/config.c",
            details={
                "allocation": "kmalloc(ncfg * sizeof(struct usb_host_config))",
                "struct_size": 272,
                "num_configs": 1
            }
        )

    def _add_vulnerable_paths(self):
        """Add vulnerable code path nodes"""
        self.nodes["quirk_entry"] = AttackNode(
            id="quirk_entry",
            name="Boot Quirk Entry",
            node_type=NodeType.ACTION,
            description="snd_usb_extigy_boot_quirk() is called",
            kernel_function="snd_usb_extigy_boot_quirk",
            kernel_file="sound/usb/quirks.c",
            line_number=1
        )

        self.nodes["boot_msg"] = AttackNode(
            id="boot_msg",
            name="Boot Control Message",
            node_type=NodeType.ACTION,
            description="Send boot command to device (request=0x10, type=0x43)",
            kernel_function="snd_usb_ctl_msg",
            kernel_file="sound/usb/quirks.c",
            details={
                "bRequest": "0x10",
                "bRequestType": "0x43",
                "wValue": "0x0001",
                "wIndex": "0x000a"
            }
        )

        self.nodes["descriptor_reread"] = AttackNode(
            id="descriptor_reread",
            name="VULNERABLE: Descriptor Re-read",
            node_type=NodeType.VULNERABILITY,
            description="usb_get_descriptor() re-reads device descriptor WITHOUT validating bNumConfigurations",
            kernel_function="usb_get_descriptor",
            kernel_file="sound/usb/quirks.c",
            details={
                "vuln_type": "Missing validation",
                "field": "bNumConfigurations",
                "original_value": 1,
                "malicious_value": 255,
                "cve": "CVE-2024-53197"
            }
        )

        self.nodes["config_reset"] = AttackNode(
            id="config_reset",
            name="Configuration Reset",
            node_type=NodeType.VULNERABILITY,
            description="usb_reset_configuration() iterates using NEW bNumConfigurations value",
            kernel_function="usb_reset_configuration",
            kernel_file="drivers/usb/core/message.c",
            details={
                "iteration": "for (i = 0; i < dev->descriptor.bNumConfigurations; i++)",
                "oob_access": "dev->config[i] where i >= original_allocation"
            }
        )

    def _add_primitives(self):
        """Add exploitation primitive nodes"""
        self.nodes["oob_read"] = AttackNode(
            id="oob_read",
            name="Out-of-Bounds Read",
            node_type=NodeType.PRIMITIVE,
            description="Read kernel memory beyond config array allocation",
            details={
                "primitive": "Arbitrary read",
                "range": "(255 - 1) * 272 = 69,088 bytes",
                "uses": ["KASLR bypass", "Info leak"]
            }
        )

        self.nodes["oob_write"] = AttackNode(
            id="oob_write",
            name="Out-of-Bounds Write",
            node_type=NodeType.PRIMITIVE,
            description="Corrupt kernel memory beyond config array allocation",
            details={
                "primitive": "Arbitrary write",
                "targets": [
                    "Adjacent slab objects",
                    "Freelist pointers",
                    "Function pointers"
                ]
            }
        )

        self.nodes["heap_corruption"] = AttackNode(
            id="heap_corruption",
            name="Heap Corruption",
            node_type=NodeType.PRIMITIVE,
            description="Corrupt SLUB heap metadata or adjacent objects",
            details={
                "techniques": [
                    "Corrupt freelist pointer for arbitrary alloc",
                    "Corrupt object data for type confusion",
                    "Overwrite function pointer for code execution"
                ]
            }
        )

    def _add_goals(self):
        """Add attack goal nodes"""
        self.nodes["info_leak"] = AttackNode(
            id="info_leak",
            name="Kernel Info Leak",
            node_type=NodeType.GOAL,
            description="Leak kernel addresses to bypass KASLR",
            details={
                "bypass": "KASLR",
                "chain_with": "CVE-2024-50302 (HID touchpad)"
            }
        )

        self.nodes["code_exec"] = AttackNode(
            id="code_exec",
            name="Kernel Code Execution",
            node_type=NodeType.GOAL,
            description="Execute arbitrary code in kernel context",
            details={
                "privilege": "Ring 0",
                "technique": "ROP chain or direct function pointer overwrite"
            }
        )

        self.nodes["root"] = AttackNode(
            id="root",
            name="Root Access",
            node_type=NodeType.GOAL,
            description="Full root privileges on device",
            details={
                "capabilities": [
                    "Dump boot partition",
                    "Disable dm-verity",
                    "Flash custom kernel",
                    "Install native Linux"
                ]
            }
        )

    def _add_edges(self):
        """Add edges connecting nodes"""
        # Entry to enumeration
        self.edges.append(AttackEdge(
            "usb_connect", "device_enum",
            EdgeType.TRIGGERS,
            "USB connection triggers enumeration"
        ))

        # Enumeration conditions
        self.edges.append(AttackEdge(
            "device_enum", "vid_pid_match",
            EdgeType.REQUIRES,
            "Enumeration checks VID:PID"
        ))

        self.edges.append(AttackEdge(
            "device_enum", "config_alloc",
            EdgeType.TRIGGERS,
            "Enumeration allocates config array"
        ))

        # VID:PID to quirk
        self.edges.append(AttackEdge(
            "vid_pid_match", "quirk_entry",
            EdgeType.ENABLES,
            "Matching VID:PID triggers quirk handler"
        ))

        # Firmware size check
        self.edges.append(AttackEdge(
            "quirk_entry", "fw_size_match",
            EdgeType.REQUIRES,
            "Quirk checks wTotalLength"
        ))

        self.edges.append(AttackEdge(
            "fw_size_match", "boot_msg",
            EdgeType.ENABLES,
            "Size match triggers boot sequence"
        ))

        # Boot message to vulnerability
        self.edges.append(AttackEdge(
            "boot_msg", "descriptor_reread",
            EdgeType.TRIGGERS,
            "Boot command causes device re-enumeration"
        ))

        # Vulnerable path
        self.edges.append(AttackEdge(
            "descriptor_reread", "config_reset",
            EdgeType.LEADS_TO,
            "New descriptor used without validation"
        ))

        # Primitives
        self.edges.append(AttackEdge(
            "config_reset", "oob_read",
            EdgeType.EXPLOITS,
            "Config iteration reads OOB"
        ))

        self.edges.append(AttackEdge(
            "config_reset", "oob_write",
            EdgeType.EXPLOITS,
            "Config iteration writes OOB"
        ))

        self.edges.append(AttackEdge(
            "oob_write", "heap_corruption",
            EdgeType.LEADS_TO,
            "OOB write corrupts heap"
        ))

        # Goals
        self.edges.append(AttackEdge(
            "oob_read", "info_leak",
            EdgeType.ENABLES,
            "OOB read leaks kernel addresses"
        ))

        self.edges.append(AttackEdge(
            "heap_corruption", "code_exec",
            EdgeType.ENABLES,
            "Heap corruption enables code execution"
        ))

        self.edges.append(AttackEdge(
            "info_leak", "code_exec",
            EdgeType.ENABLES,
            "Info leak enables reliable exploitation",
            probability=0.9
        ))

        self.edges.append(AttackEdge(
            "code_exec", "root",
            EdgeType.LEADS_TO,
            "Kernel code exec -> root"
        ))

    def _compute_attack_paths(self):
        """Compute complete attack paths through the graph"""
        # Primary exploitation path
        self.paths.append(AttackPath(
            name="Primary OOB Exploitation",
            description="Standard CVE-2024-53197 exploitation via Extigy emulation",
            nodes=[
                "usb_connect",
                "device_enum",
                "vid_pid_match",
                "config_alloc",
                "quirk_entry",
                "fw_size_match",
                "boot_msg",
                "descriptor_reread",
                "config_reset",
                "oob_write",
                "heap_corruption",
                "code_exec",
                "root"
            ],
            success_probability=0.7,
            requirements=[
                "USB attack hardware (Pi Zero, Facedancer)",
                "USB-C OTG adapter",
                "Physical access to device"
            ],
            mitigations=[
                "Kernel 4.19.325+ (patched)",
                "USB device authorization",
                "Disable USB audio driver"
            ]
        ))

        # Info leak chain
        self.paths.append(AttackPath(
            name="KASLR Bypass Chain",
            description="Chain with CVE-2024-50302 for reliable exploitation",
            nodes=[
                "usb_connect",
                "device_enum",
                "vid_pid_match",
                "config_alloc",
                "quirk_entry",
                "fw_size_match",
                "boot_msg",
                "descriptor_reread",
                "config_reset",
                "oob_read",
                "info_leak",
                "code_exec",
                "root"
            ],
            success_probability=0.85,
            requirements=[
                "USB attack hardware",
                "CVE-2024-50302 exploit (HID)",
                "Multiple USB device emulations"
            ],
            mitigations=[
                "Kernel patches for both CVEs",
                "CONFIG_HARDENED_USERCOPY"
            ]
        ))

    def to_json(self) -> str:
        """Export graph to JSON"""
        return json.dumps({
            "nodes": {k: v.to_dict() for k, v in self.nodes.items()},
            "edges": [e.to_dict() for e in self.edges],
            "paths": [asdict(p) for p in self.paths]
        }, indent=2)

    def to_mermaid(self) -> str:
        """Export graph to Mermaid diagram format"""
        lines = ["graph TD"]

        # Define node styles
        lines.append("    %% Node styles")
        lines.append("    classDef entry fill:#4CAF50,color:white")
        lines.append("    classDef condition fill:#2196F3,color:white")
        lines.append("    classDef action fill:#607D8B,color:white")
        lines.append("    classDef vuln fill:#f44336,color:white")
        lines.append("    classDef primitive fill:#FF9800,color:white")
        lines.append("    classDef goal fill:#9C27B0,color:white")
        lines.append("")

        # Add nodes
        for node_id, node in self.nodes.items():
            label = node.name.replace('"', "'")
            lines.append(f'    {node_id}["{label}"]')

        lines.append("")

        # Add edges
        for edge in self.edges:
            arrow = "-->"
            if edge.edge_type == EdgeType.REQUIRES:
                arrow = "-..->"
            elif edge.edge_type == EdgeType.EXPLOITS:
                arrow = "==>"
            lines.append(f"    {edge.source} {arrow} {edge.target}")

        lines.append("")

        # Apply styles
        for node_id, node in self.nodes.items():
            lines.append(f"    class {node_id} {node.node_type.value}")

        return "\n".join(lines)

    def print_summary(self):
        """Print attack graph summary"""
        print("=" * 70)
        print("CVE-2024-53197 Attack Graph Summary")
        print("=" * 70)
        print()

        print(f"Nodes: {len(self.nodes)}")
        print(f"Edges: {len(self.edges)}")
        print(f"Attack Paths: {len(self.paths)}")
        print()

        print("Attack Paths:")
        print("-" * 40)
        for path in self.paths:
            print(f"\n{path.name}")
            print(f"  Description: {path.description}")
            print(f"  Success Probability: {path.success_probability:.0%}")
            print(f"  Steps: {len(path.nodes)}")
            print(f"  Requirements:")
            for req in path.requirements:
                print(f"    - {req}")

        print()
        print("Vulnerability Node:")
        print("-" * 40)
        vuln_node = self.nodes["descriptor_reread"]
        print(f"  Function: {vuln_node.kernel_function}()")
        print(f"  File: {vuln_node.kernel_file}")
        print(f"  CVE: {vuln_node.details['cve']}")
        print(f"  Type: {vuln_node.details['vuln_type']}")


def main():
    """Generate and display attack graph"""
    graph = CVE202453197AttackGraph()

    # Print summary
    graph.print_summary()

    # Save JSON
    json_output = graph.to_json()
    with open("attack_graph.json", "w") as f:
        f.write(json_output)
    print("\nSaved attack_graph.json")

    # Save Mermaid diagram
    mermaid_output = graph.to_mermaid()
    with open("attack_graph.mmd", "w") as f:
        f.write(mermaid_output)
    print("Saved attack_graph.mmd")

    # Print Mermaid for copy/paste
    print("\n" + "=" * 70)
    print("Mermaid Diagram (paste into mermaid.live):")
    print("=" * 70)
    print(mermaid_output)


if __name__ == "__main__":
    main()
