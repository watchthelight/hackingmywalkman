#!/usr/bin/env python3
"""
SLUB Heap Allocator Simulation

Models Linux kernel SLUB allocator behavior for kernel 4.19.157
to predict heap layout and identify exploitation targets.

Target: Sony NW-A306 Walkman
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Any
from enum import Enum
import random


class SlabState(Enum):
    """Slab allocation states"""
    FULL = "full"
    PARTIAL = "partial"
    EMPTY = "empty"


@dataclass
class SlabObject:
    """Represents a single object in a slab"""
    address: int
    size: int
    name: str
    allocated: bool = True
    data: bytes = field(default_factory=bytes)

    def __str__(self):
        state = "ALLOC" if self.allocated else "FREE"
        return f"[{state}] 0x{self.address:08x} - {self.name} ({self.size} bytes)"


@dataclass
class SlabPage:
    """Represents a slab page containing objects"""
    base_address: int
    page_size: int = 4096
    object_size: int = 0
    objects: List[SlabObject] = field(default_factory=list)
    freelist: List[int] = field(default_factory=list)

    @property
    def num_objects(self) -> int:
        return self.page_size // self.object_size if self.object_size else 0

    @property
    def state(self) -> SlabState:
        free_count = len(self.freelist)
        if free_count == 0:
            return SlabState.FULL
        elif free_count == self.num_objects:
            return SlabState.EMPTY
        return SlabState.PARTIAL


@dataclass
class SlabCache:
    """
    Represents a SLUB kmem_cache

    Common caches for USB audio exploitation:
    - kmalloc-256
    - kmalloc-512
    - kmalloc-1024
    - usb_host_config (if dedicated cache)
    """
    name: str
    object_size: int
    pages: List[SlabPage] = field(default_factory=list)
    cpu_partial: List[SlabPage] = field(default_factory=list)

    # Statistics
    total_allocations: int = 0
    total_frees: int = 0

    def get_size_with_metadata(self) -> int:
        """Object size including freelist pointer and red zone"""
        # SLUB uses the first word of free objects as freelist pointer
        # May include red zones in debug builds
        return max(self.object_size, 8)  # Minimum pointer size


class SLUBHeapSimulator:
    """
    Simulates Linux SLUB allocator for exploitation analysis

    Key behaviors modeled:
    - Size-based cache selection
    - Per-CPU partial lists
    - Freelist ordering (LIFO)
    - Object adjacency within pages
    """

    # Standard kmalloc cache sizes
    KMALLOC_SIZES = [8, 16, 32, 64, 96, 128, 192, 256, 512, 1024, 2048, 4096, 8192]

    def __init__(self, base_address: int = 0xFFFF000000000000):
        self.base_address = base_address
        self.next_page_addr = base_address
        self.caches: Dict[str, SlabCache] = {}
        self.allocation_log: List[Dict] = []

        # Initialize standard kmalloc caches
        self._init_kmalloc_caches()

    def _init_kmalloc_caches(self):
        """Initialize standard kmalloc-N caches"""
        for size in self.KMALLOC_SIZES:
            cache_name = f"kmalloc-{size}"
            self.caches[cache_name] = SlabCache(
                name=cache_name,
                object_size=size
            )

    def _get_cache_for_size(self, size: int) -> SlabCache:
        """Select appropriate cache for allocation size"""
        for cache_size in self.KMALLOC_SIZES:
            if size <= cache_size:
                return self.caches[f"kmalloc-{cache_size}"]
        # For larger allocations, use page allocator
        raise ValueError(f"Size {size} too large for SLUB")

    def _allocate_new_page(self, cache: SlabCache) -> SlabPage:
        """Allocate a new slab page"""
        page = SlabPage(
            base_address=self.next_page_addr,
            object_size=cache.object_size
        )
        self.next_page_addr += page.page_size

        # Initialize objects and freelist
        num_objects = page.num_objects
        for i in range(num_objects):
            addr = page.base_address + (i * cache.object_size)
            obj = SlabObject(
                address=addr,
                size=cache.object_size,
                name="free",
                allocated=False
            )
            page.objects.append(obj)
            page.freelist.append(addr)

        # Freelist is LIFO - last object first
        page.freelist.reverse()

        cache.pages.append(page)
        return page

    def _find_free_object(self, cache: SlabCache) -> Optional[Tuple[SlabPage, int]]:
        """Find a free object in existing pages"""
        # Check partial pages first (CPU partial list)
        for page in cache.cpu_partial:
            if page.freelist:
                return page, page.freelist[0]

        # Check other partial pages
        for page in cache.pages:
            if page.state == SlabState.PARTIAL and page.freelist:
                return page, page.freelist[0]

        return None

    def kmalloc(self, size: int, name: str = "object") -> int:
        """
        Simulate kmalloc()

        Returns the address of allocated object
        """
        cache = self._get_cache_for_size(size)

        # Find or create a page with free objects
        result = self._find_free_object(cache)
        if result is None:
            page = self._allocate_new_page(cache)
        else:
            page, _ = result

        # Allocate from freelist (LIFO)
        addr = page.freelist.pop(0)

        # Update object state
        for obj in page.objects:
            if obj.address == addr:
                obj.allocated = True
                obj.name = name
                break

        cache.total_allocations += 1

        # Log allocation
        self.allocation_log.append({
            "operation": "kmalloc",
            "address": addr,
            "size": size,
            "actual_size": cache.object_size,
            "cache": cache.name,
            "name": name
        })

        return addr

    def kfree(self, addr: int) -> bool:
        """
        Simulate kfree()

        Returns True if successful
        """
        # Find the page containing this address
        for cache in self.caches.values():
            for page in cache.pages:
                if page.base_address <= addr < page.base_address + page.page_size:
                    # Find and free the object
                    for obj in page.objects:
                        if obj.address == addr and obj.allocated:
                            obj.allocated = False
                            obj.name = "free"
                            # Add to freelist (LIFO - add at front)
                            page.freelist.insert(0, addr)
                            cache.total_frees += 1

                            self.allocation_log.append({
                                "operation": "kfree",
                                "address": addr,
                                "cache": cache.name
                            })
                            return True
        return False

    def get_adjacent_objects(self, addr: int, count: int = 5) -> List[SlabObject]:
        """
        Get objects adjacent to a given address

        Critical for predicting OOB corruption targets
        """
        adjacent = []

        for cache in self.caches.values():
            for page in cache.pages:
                for i, obj in enumerate(page.objects):
                    if obj.address == addr:
                        # Get objects after this one
                        for j in range(i + 1, min(i + 1 + count, len(page.objects))):
                            adjacent.append(page.objects[j])
                        return adjacent

        return adjacent

    def get_objects_in_range(self, start: int, end: int) -> List[SlabObject]:
        """
        Get all objects in a memory range

        Used to identify what gets corrupted by OOB access
        """
        victims = []

        for cache in self.caches.values():
            for page in cache.pages:
                for obj in page.objects:
                    if start <= obj.address < end:
                        victims.append(obj)

        return sorted(victims, key=lambda x: x.address)

    def spray(self, size: int, count: int, name: str = "spray") -> List[int]:
        """
        Perform heap spray - allocate many objects of same size

        Used for heap feng shui to position target objects
        """
        addresses = []
        for i in range(count):
            addr = self.kmalloc(size, f"{name}_{i}")
            addresses.append(addr)
        return addresses

    def create_holes(self, addresses: List[int], pattern: str = "alternate") -> List[int]:
        """
        Create holes in allocated objects for heap shaping

        Patterns:
        - "alternate": free every other object
        - "first_half": free first half
        - "random": random selection
        """
        freed = []

        if pattern == "alternate":
            for i, addr in enumerate(addresses):
                if i % 2 == 0:
                    self.kfree(addr)
                    freed.append(addr)
        elif pattern == "first_half":
            for addr in addresses[:len(addresses)//2]:
                self.kfree(addr)
                freed.append(addr)
        elif pattern == "random":
            import random
            for addr in random.sample(addresses, len(addresses)//2):
                self.kfree(addr)
                freed.append(addr)

        return freed

    def dump_cache(self, cache_name: str) -> str:
        """Dump state of a cache for debugging"""
        if cache_name not in self.caches:
            return f"Cache {cache_name} not found"

        cache = self.caches[cache_name]
        lines = [
            f"Cache: {cache.name}",
            f"Object size: {cache.object_size}",
            f"Pages: {len(cache.pages)}",
            f"Allocations: {cache.total_allocations}",
            f"Frees: {cache.total_frees}",
            ""
        ]

        for i, page in enumerate(cache.pages):
            lines.append(f"  Page {i}: 0x{page.base_address:x} ({page.state.value})")
            for obj in page.objects:
                lines.append(f"    {obj}")

        return "\n".join(lines)

    def analyze_oob_impact(self, base_addr: int, oob_size: int) -> Dict[str, Any]:
        """
        Analyze the impact of an out-of-bounds access

        Returns details about what memory will be corrupted
        """
        oob_start = base_addr
        oob_end = base_addr + oob_size

        victims = self.get_objects_in_range(oob_start, oob_end)

        analysis = {
            "oob_range": {
                "start": oob_start,
                "end": oob_end,
                "size": oob_size
            },
            "victims": [],
            "exploitation_vectors": []
        }

        for victim in victims:
            victim_info = {
                "address": victim.address,
                "name": victim.name,
                "size": victim.size,
                "allocated": victim.allocated,
                "offset_from_start": victim.address - oob_start
            }
            analysis["victims"].append(victim_info)

            # Identify exploitation potential
            if victim.allocated:
                analysis["exploitation_vectors"].append(
                    f"Corrupt allocated object '{victim.name}' at offset {victim_info['offset_from_start']}"
                )
            else:
                analysis["exploitation_vectors"].append(
                    f"Corrupt freelist pointer at offset {victim_info['offset_from_start']}"
                )

        return analysis


class USBHostConfigAllocator:
    """
    Specialized allocator for USB host config structures

    Models the specific allocation pattern used in USB audio exploitation
    """

    # usb_host_config size on ARM64 (approximate)
    USB_HOST_CONFIG_SIZE = 272

    def __init__(self, heap: SLUBHeapSimulator):
        self.heap = heap

    def allocate_configs(self, num_configs: int) -> int:
        """
        Allocate array of usb_host_config structures

        Mimics: dev->config = kmalloc(ncfg * sizeof(struct usb_host_config), GFP_KERNEL)
        """
        total_size = num_configs * self.USB_HOST_CONFIG_SIZE
        return self.heap.kmalloc(total_size, "usb_host_config_array")

    def simulate_oob_access(self, base_addr: int,
                           original_configs: int,
                           malicious_configs: int) -> Dict[str, Any]:
        """
        Simulate the OOB access from CVE-2024-53197

        When usb_reset_configuration iterates using the new bNumConfigurations
        """
        allocated_size = original_configs * self.USB_HOST_CONFIG_SIZE
        accessed_size = malicious_configs * self.USB_HOST_CONFIG_SIZE
        oob_size = accessed_size - allocated_size

        oob_start = base_addr + allocated_size

        result = {
            "allocated": {
                "configs": original_configs,
                "size": allocated_size,
                "range": (base_addr, base_addr + allocated_size)
            },
            "accessed": {
                "configs": malicious_configs,
                "size": accessed_size,
                "range": (base_addr, base_addr + accessed_size)
            },
            "oob": {
                "configs": malicious_configs - original_configs,
                "size": oob_size,
                "range": (oob_start, oob_start + oob_size)
            }
        }

        # Analyze what's in the OOB region
        result["impact"] = self.heap.analyze_oob_impact(oob_start, oob_size)

        return result


def main():
    """Demonstrate heap simulation for CVE-2024-53197"""
    print("=" * 70)
    print("SLUB Heap Allocator Simulation for CVE-2024-53197")
    print("Target: Sony NW-A306 Walkman (kernel 4.19.157)")
    print("=" * 70)
    print()

    # Create heap simulator
    heap = SLUBHeapSimulator()

    # Create USB-specific allocator
    usb_alloc = USBHostConfigAllocator(heap)

    print("[PHASE 1] Initial USB Enumeration")
    print("-" * 40)

    # Allocate initial config (bNumConfigurations=1)
    initial_configs = 1
    config_addr = usb_alloc.allocate_configs(initial_configs)
    print(f"Allocated {initial_configs} usb_host_config at 0x{config_addr:x}")
    print(f"Allocation size: {initial_configs * usb_alloc.USB_HOST_CONFIG_SIZE} bytes")
    print()

    print("[PHASE 2] Heap Spray (Simulating Other Allocations)")
    print("-" * 40)

    # Simulate other kernel allocations that might end up adjacent
    other_objects = []
    for i in range(5):
        addr = heap.kmalloc(256, f"other_object_{i}")
        other_objects.append(addr)
        print(f"Allocated other_object_{i} at 0x{addr:x}")
    print()

    print("[PHASE 3] OOB Access Simulation")
    print("-" * 40)

    # Simulate malicious re-enumeration with bNumConfigurations=255
    malicious_configs = 255
    oob_result = usb_alloc.simulate_oob_access(
        config_addr,
        initial_configs,
        malicious_configs
    )

    print(f"Original allocation: {oob_result['allocated']['configs']} configs "
          f"({oob_result['allocated']['size']} bytes)")
    print(f"Malicious access: {oob_result['accessed']['configs']} configs "
          f"({oob_result['accessed']['size']} bytes)")
    print(f"OOB access: {oob_result['oob']['configs']} extra configs "
          f"({oob_result['oob']['size']} bytes)")
    print()

    print("[PHASE 4] Impact Analysis")
    print("-" * 40)

    impact = oob_result["impact"]
    print(f"OOB Range: 0x{impact['oob_range']['start']:x} - 0x{impact['oob_range']['end']:x}")
    print(f"Potential victims: {len(impact['victims'])}")

    for victim in impact["victims"]:
        state = "ALLOCATED" if victim["allocated"] else "FREE"
        print(f"  [{state}] 0x{victim['address']:x} - {victim['name']} "
              f"(offset +{victim['offset_from_start']})")

    print()
    print("Exploitation vectors:")
    for vector in impact["exploitation_vectors"]:
        print(f"  - {vector}")


if __name__ == "__main__":
    main()
