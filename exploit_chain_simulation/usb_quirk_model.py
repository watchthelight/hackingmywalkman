#!/usr/bin/env python3
"""
CVE-2024-53197 USB Quirk Execution Model

Simulates the kernel execution path through snd_usb_extigy_boot_quirk()
to understand the out-of-bounds access vulnerability.

Target: Sony NW-A306 Walkman (kernel 4.19.157)
"""

import struct
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from enum import Enum, auto

# USB Descriptor Types
USB_DT_DEVICE = 0x01
USB_DT_CONFIG = 0x02
USB_DT_STRING = 0x03
USB_DT_INTERFACE = 0x04
USB_DT_ENDPOINT = 0x05

# Extigy Constants
EXTIGY_FIRMWARE_SIZE_OLD = 794
EXTIGY_FIRMWARE_SIZE_NEW = 483
EXTIGY_VID = 0x041e
EXTIGY_PID = 0x3000
FASTTRACKPRO_VID = 0x0763
FASTTRACKPRO_PID = 0x2012

# Boot Quirk Control Message
BOOT_QUIRK_REQUEST = 0x10
BOOT_QUIRK_REQUEST_TYPE = 0x43
BOOT_QUIRK_VALUE = 0x0001
BOOT_QUIRK_INDEX = 0x000a


class QuirkState(Enum):
    """State machine for boot quirk execution"""
    INITIAL = auto()
    ENUMERATED = auto()
    BOOT_QUIRK_TRIGGERED = auto()
    DESCRIPTOR_RE_READ = auto()
    CONFIG_RESET = auto()
    OOB_ACCESS = auto()
    COMPLETE = auto()


@dataclass
class USBDeviceDescriptor:
    """USB Device Descriptor (18 bytes)"""
    bLength: int = 18
    bDescriptorType: int = USB_DT_DEVICE
    bcdUSB: int = 0x0200
    bDeviceClass: int = 0x00
    bDeviceSubClass: int = 0x00
    bDeviceProtocol: int = 0x00
    bMaxPacketSize0: int = 64
    idVendor: int = 0x0000
    idProduct: int = 0x0000
    bcdDevice: int = 0x0100
    iManufacturer: int = 0
    iProduct: int = 0
    iSerialNumber: int = 0
    bNumConfigurations: int = 1  # CRITICAL FIELD FOR EXPLOIT

    def to_bytes(self) -> bytes:
        """Serialize to USB wire format"""
        return struct.pack('<BBHBBBBHHHBBBB',
            self.bLength,
            self.bDescriptorType,
            self.bcdUSB,
            self.bDeviceClass,
            self.bDeviceSubClass,
            self.bDeviceProtocol,
            self.bMaxPacketSize0,
            self.idVendor,
            self.idProduct,
            self.bcdDevice,
            self.iManufacturer,
            self.iProduct,
            self.iSerialNumber,
            self.bNumConfigurations
        )

    @classmethod
    def from_bytes(cls, data: bytes) -> 'USBDeviceDescriptor':
        """Deserialize from USB wire format"""
        fields = struct.unpack('<BBHBBBBHHHBBBB', data[:18])
        return cls(
            bLength=fields[0],
            bDescriptorType=fields[1],
            bcdUSB=fields[2],
            bDeviceClass=fields[3],
            bDeviceSubClass=fields[4],
            bDeviceProtocol=fields[5],
            bMaxPacketSize0=fields[6],
            idVendor=fields[7],
            idProduct=fields[8],
            bcdDevice=fields[9],
            iManufacturer=fields[10],
            iProduct=fields[11],
            iSerialNumber=fields[12],
            bNumConfigurations=fields[13]
        )


@dataclass
class USBConfigDescriptor:
    """USB Configuration Descriptor"""
    bLength: int = 9
    bDescriptorType: int = USB_DT_CONFIG
    wTotalLength: int = 0  # Total length including all subordinate descriptors
    bNumInterfaces: int = 1
    bConfigurationValue: int = 1
    iConfiguration: int = 0
    bmAttributes: int = 0x80
    bMaxPower: int = 250


@dataclass
class USBHostConfig:
    """
    Kernel's usb_host_config structure (simplified)

    This is what gets allocated based on bNumConfigurations.
    Size on ARM64: ~272 bytes (varies by kernel version)
    """
    desc: USBConfigDescriptor = field(default_factory=USBConfigDescriptor)
    string: str = ""
    interfaces: List[Any] = field(default_factory=list)

    # Simulated kernel structure size
    STRUCT_SIZE = 272  # Approximate size on ARM64


@dataclass
class USBDevice:
    """Simulated USB device structure"""
    descriptor: USBDeviceDescriptor = field(default_factory=USBDeviceDescriptor)
    config: List[USBHostConfig] = field(default_factory=list)
    actconfig: Optional[USBHostConfig] = None

    # Memory tracking
    config_allocation_size: int = 0
    config_base_address: int = 0


class ExtigyBootQuirkSimulator:
    """
    Simulates the vulnerable snd_usb_extigy_boot_quirk() execution path
    """

    def __init__(self, heap_model=None):
        self.state = QuirkState.INITIAL
        self.device: Optional[USBDevice] = None
        self.heap = heap_model
        self.log: List[str] = []
        self.original_num_configs = 0
        self.malicious_num_configs = 0

    def log_event(self, msg: str):
        """Log execution events"""
        self.log.append(f"[{self.state.name}] {msg}")
        print(f"[{self.state.name}] {msg}")

    def usb_get_configuration(self, device: USBDevice) -> int:
        """
        Simulate usb_get_configuration() - initial allocation

        Kernel code:
        dev->config = kmalloc(ncfg * sizeof(struct usb_host_config), GFP_KERNEL);
        """
        ncfg = device.descriptor.bNumConfigurations
        self.original_num_configs = ncfg

        alloc_size = ncfg * USBHostConfig.STRUCT_SIZE
        device.config_allocation_size = alloc_size

        # Simulate heap allocation
        if self.heap:
            addr = self.heap.kmalloc(alloc_size, "usb_host_config array")
            device.config_base_address = addr

        # Create config array
        device.config = [USBHostConfig() for _ in range(ncfg)]
        device.actconfig = device.config[0] if device.config else None

        self.log_event(f"usb_get_configuration: allocated {ncfg} configs ({alloc_size} bytes)")
        return 0

    def check_extigy_device(self, device: USBDevice) -> bool:
        """Check if device matches Extigy VID:PID"""
        vid = device.descriptor.idVendor
        pid = device.descriptor.idProduct

        if (vid == EXTIGY_VID and pid == EXTIGY_PID) or \
           (vid == FASTTRACKPRO_VID and pid == FASTTRACKPRO_PID):
            self.log_event(f"Device matches quirk: VID={vid:04x} PID={pid:04x}")
            return True
        return False

    def check_firmware_size(self, device: USBDevice) -> bool:
        """Check if wTotalLength matches firmware boot constants"""
        if device.actconfig is None:
            return False

        total_length = device.actconfig.desc.wTotalLength

        if total_length in (EXTIGY_FIRMWARE_SIZE_OLD, EXTIGY_FIRMWARE_SIZE_NEW):
            self.log_event(f"Firmware size matches: wTotalLength={total_length}")
            return True
        return False

    def snd_usb_ctl_msg(self, device: USBDevice, pipe: int,
                        request: int, request_type: int,
                        value: int, index: int) -> int:
        """
        Simulate sending the boot control message

        This triggers the device to "reconnect" with different descriptors
        """
        self.log_event(f"Control message: request=0x{request:02x} type=0x{request_type:02x} "
                      f"value=0x{value:04x} index=0x{index:04x}")

        if request == BOOT_QUIRK_REQUEST and request_type == BOOT_QUIRK_REQUEST_TYPE:
            self.state = QuirkState.BOOT_QUIRK_TRIGGERED
            self.log_event("Boot quirk control message sent - device will re-enumerate")
            return 0
        return -1

    def usb_get_descriptor(self, device: USBDevice,
                          malicious_num_configs: int = 255) -> int:
        """
        Simulate usb_get_descriptor() after boot quirk

        VULNERABLE: Re-reads device descriptor WITHOUT validating that
        bNumConfigurations hasn't exceeded original allocation
        """
        self.state = QuirkState.DESCRIPTOR_RE_READ

        # Malicious device now reports larger bNumConfigurations
        old_num_configs = device.descriptor.bNumConfigurations
        device.descriptor.bNumConfigurations = malicious_num_configs
        self.malicious_num_configs = malicious_num_configs

        self.log_event(f"VULNERABLE: Re-read descriptor with bNumConfigurations "
                      f"changed from {old_num_configs} to {malicious_num_configs}")
        self.log_event(f"Original allocation: {self.original_num_configs} configs "
                      f"({self.original_num_configs * USBHostConfig.STRUCT_SIZE} bytes)")
        self.log_event(f"New descriptor claims: {malicious_num_configs} configs "
                      f"({malicious_num_configs * USBHostConfig.STRUCT_SIZE} bytes)")

        return 0

    def usb_reset_configuration(self, device: USBDevice) -> int:
        """
        Simulate usb_reset_configuration()

        This will iterate over config array using the NEW bNumConfigurations
        value, causing out-of-bounds access
        """
        self.state = QuirkState.CONFIG_RESET

        num_configs = device.descriptor.bNumConfigurations
        original_alloc = self.original_num_configs

        if num_configs > original_alloc:
            self.state = QuirkState.OOB_ACCESS
            oob_count = num_configs - original_alloc
            oob_bytes = oob_count * USBHostConfig.STRUCT_SIZE

            self.log_event(f"OUT-OF-BOUNDS ACCESS DETECTED!")
            self.log_event(f"Accessing {oob_count} unallocated config structures")
            self.log_event(f"OOB access size: {oob_bytes} bytes past allocation")

            if self.heap:
                # Show what memory will be corrupted
                base = device.config_base_address
                alloc_end = base + device.config_allocation_size
                oob_start = alloc_end
                oob_end = base + (num_configs * USBHostConfig.STRUCT_SIZE)

                self.log_event(f"Allocation: 0x{base:x} - 0x{alloc_end:x}")
                self.log_event(f"OOB Range: 0x{oob_start:x} - 0x{oob_end:x}")

                # Check what's in the OOB region
                victims = self.heap.get_objects_in_range(oob_start, oob_end)
                for victim in victims:
                    self.log_event(f"VICTIM: {victim}")

            return -1  # Would cause kernel crash/corruption

        return 0

    def snd_usb_extigy_boot_quirk(self, device: USBDevice,
                                  malicious_num_configs: int = 255) -> int:
        """
        Main vulnerable function simulation

        Kernel 4.19.157 sound/usb/quirks.c:

        static int snd_usb_extigy_boot_quirk(struct usb_device *dev,
                                             struct usb_interface *intf)
        {
            struct usb_host_config *config = dev->actconfig;
            int err;

            if (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||
                le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {

                // Step 1: Send boot command
                err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
                                      0x10, 0x43, 0x0001, 0x000a, NULL, 0);

                // Step 2: VULNERABLE - Re-read without validation
                err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
                        &dev->descriptor, sizeof(dev->descriptor));

                // Step 3: Uses new bNumConfigurations, causes OOB
                err = usb_reset_configuration(dev);

                return -ENODEV;
            }
            return 0;
        }
        """
        self.device = device
        self.state = QuirkState.ENUMERATED

        self.log_event("=" * 60)
        self.log_event("snd_usb_extigy_boot_quirk() EXECUTION START")
        self.log_event("=" * 60)

        # Check firmware size (trigger condition)
        if not self.check_firmware_size(device):
            self.log_event("Firmware size mismatch - quirk not triggered")
            return 0

        # Step 1: Send boot control message
        err = self.snd_usb_ctl_msg(device, 0,  # pipe
                                   BOOT_QUIRK_REQUEST,
                                   BOOT_QUIRK_REQUEST_TYPE,
                                   BOOT_QUIRK_VALUE,
                                   BOOT_QUIRK_INDEX)
        if err < 0:
            self.log_event(f"Boot message failed: {err}")
            return err

        # Step 2: Re-read descriptor (VULNERABLE)
        err = self.usb_get_descriptor(device, malicious_num_configs)
        if err < 0:
            self.log_event(f"Get descriptor failed: {err}")

        # Step 3: Reset configuration (triggers OOB)
        err = self.usb_reset_configuration(device)
        if err < 0:
            self.log_event(f"Reset configuration failed (OOB triggered): {err}")

        self.state = QuirkState.COMPLETE
        self.log_event("=" * 60)
        self.log_event("EXECUTION COMPLETE")
        self.log_event("=" * 60)

        return -19  # -ENODEV

    def get_exploitation_analysis(self) -> Dict[str, Any]:
        """Generate analysis of exploitation potential"""
        if self.state != QuirkState.COMPLETE:
            return {"error": "Simulation not complete"}

        oob_configs = self.malicious_num_configs - self.original_num_configs
        oob_bytes = oob_configs * USBHostConfig.STRUCT_SIZE

        return {
            "vulnerable": oob_configs > 0,
            "original_allocation": {
                "num_configs": self.original_num_configs,
                "bytes": self.original_num_configs * USBHostConfig.STRUCT_SIZE
            },
            "malicious_descriptor": {
                "num_configs": self.malicious_num_configs,
                "claimed_bytes": self.malicious_num_configs * USBHostConfig.STRUCT_SIZE
            },
            "oob_access": {
                "extra_configs": oob_configs,
                "bytes": oob_bytes,
                "exploitation_potential": self._assess_exploitation(oob_bytes)
            }
        }

    def _assess_exploitation(self, oob_bytes: int) -> str:
        """Assess exploitation potential based on OOB size"""
        if oob_bytes >= 4096:
            return "HIGH - Large OOB, multiple slab objects affected"
        elif oob_bytes >= 1024:
            return "MEDIUM - Multiple adjacent objects potentially corrupted"
        elif oob_bytes >= 256:
            return "LOW-MEDIUM - Adjacent slab object corruption possible"
        else:
            return "LOW - Limited corruption range"


def create_malicious_extigy() -> USBDevice:
    """Create a malicious Extigy device for testing"""
    device = USBDevice()
    device.descriptor = USBDeviceDescriptor(
        idVendor=EXTIGY_VID,
        idProduct=EXTIGY_PID,
        bNumConfigurations=1  # Initial - will be changed to 255
    )
    # Set firmware size to trigger quirk
    device.config = [USBHostConfig()]
    device.config[0].desc.wTotalLength = EXTIGY_FIRMWARE_SIZE_OLD
    device.actconfig = device.config[0]

    return device


def main():
    """Run the CVE-2024-53197 simulation"""
    print("=" * 70)
    print("CVE-2024-53197 USB Audio Boot Quirk Exploit Simulation")
    print("Target: Sony NW-A306 Walkman (kernel 4.19.157)")
    print("=" * 70)
    print()

    # Create malicious device
    device = create_malicious_extigy()

    # Create simulator
    simulator = ExtigyBootQuirkSimulator()

    # Simulate initial enumeration
    print("[PHASE 1] Initial USB Enumeration")
    print("-" * 40)
    simulator.usb_get_configuration(device)
    print()

    # Check device identity
    print("[PHASE 2] Device Identification")
    print("-" * 40)
    if simulator.check_extigy_device(device):
        print("Device identified as Extigy - proceeding with quirk")
    print()

    # Run the vulnerable quirk
    print("[PHASE 3] Vulnerable Boot Quirk Execution")
    print("-" * 40)
    result = simulator.snd_usb_extigy_boot_quirk(device, malicious_num_configs=255)
    print()

    # Analysis
    print("[PHASE 4] Exploitation Analysis")
    print("-" * 40)
    analysis = simulator.get_exploitation_analysis()

    print(f"Vulnerable: {analysis['vulnerable']}")
    print(f"Original allocation: {analysis['original_allocation']['num_configs']} configs "
          f"({analysis['original_allocation']['bytes']} bytes)")
    print(f"Malicious claim: {analysis['malicious_descriptor']['num_configs']} configs")
    print(f"OOB access: {analysis['oob_access']['extra_configs']} extra configs "
          f"({analysis['oob_access']['bytes']} bytes)")
    print(f"Exploitation potential: {analysis['oob_access']['exploitation_potential']}")


if __name__ == "__main__":
    main()
